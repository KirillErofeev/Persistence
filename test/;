--{-#language MultiParamTypeClasses #-}
{-#language RankNTypes #-}
{-#language FlexibleInstances #-}

module Homology where

import qualified Data.Map.Strict as Map 

class Simplex s where
  dimension     :: s a -> Int
  simplexToList :: s a -> [a]
  -- length . simplexToList $ s a = 1 + (dimension $ s a)
  --
class Simplex s => FSimplex s where
    degree :: s a -> Int
    updDegree :: (Int -> Int) -> s a -> s a
    incDegree :: s a -> s a
    incDegree = updDegree (+1)

--instance Simplex ListSimplex where
--  dimension     (ListSimplex l) = length l - 1
--  simplexToList (ListSimplex l) = l

instance Simplex s => Simplex (DSimplex s) where
  dimension     (DSimplex l d) = dimension     l
  simplexToList (DSimplex l d) = simplexToList l

--instance Ord a => Ord (ListSimplex a) where
--  compare a b | dimension a > dimension b = GT 
--              | dimension a < dimension b = LT
--              | otherwise                 = compare a b

instance (Ord a, FSimplex s) => Ord (s a) where
  compare a b | degree    a /= degree    b = compare (degree    a) (degree    b)
              | dimension a /= dimension b = compare (dimension a) (dimension b)
              | otherwise                  = compare a b

--instance (Ord a, Simplex s) => Ord (s a) where
--  compare a b | dimension a > dimension b = GT
--              | dimension a < dimension b = LT
--              | otherwise                 = compare a b

instance (Eq a, Simplex s) => Eq (s a) where
  l == l0 | dimension l /= dimension l0 = False
          | otherwise                  = all (uncurry (==) ) $ zip (simplexToList l) (simplexToList l0)
  --l == l0 = simplexToList l == simplexToList l0
  --a == b = True

data ListSimplex a = ListSimplex [a] deriving (Show)
data DSimplex simplex a = DSimplex {simplex :: simplex a, dSimplex :: Int}

class Filtration f where
   emptyFiltration :: f s a
   addSimplex :: (FSimplex s) => f s a -> s a -> f s a
   updDegrees :: (FSimplex s) => (Int -> Int) -> f s a -> f s a
   incDegrees :: (FSimplex s) => f s a -> f s a
   incDegrees = updDegrees (+1)

instance Filtration ListFiltration where
   emptyFiltration = ListFiltration []
   addSimplex (ListFiltration l) s = ListFiltration (s:l)
   updDegrees f (ListFiltration l) = ListFiltration $ (updDegree f) <$> l

instance Simplex a => FSimplex (DSimplex a) where
  degree = dSimplex
  updDegree f s = s {dSimplex = f $ dSimplex s}

class Metric a where
  distance :: a -> a -> Double

data ListFiltration fsimplex a = ListFiltration [fsimplex a]
--data ListFiltration a b = ListFiltration [a b]

data Point a = Point {x :: a, y :: a}

instance RealFloat a => Metric (Point a) where
  distance (Point a b) (Point a0 b0) = realToFrac $ sqrt $ (a - a0)^2 + (b - b0)^2

instance Metric Double where
  distance a b = abs $ a - b

data PointCloud a = PointCloud [Point a]

--buildFiltration :: PointCloud a -> ListFiltration  a
--metricFiltration dists pointCloud = foldr addNewGrade emptyFiltration pds where
--  pds = toPairs dists
--  addNewGrade (s,f) filtration = addSimplex incDegrees filtration
--  pcDists = distances pointCloud
--  newSimplexes (s,f) =  filter (\(_,d) -> d >= s && d < f) pcDists
--
--toPairs (x:y:xs) = (x,y) : toPairs (y:xs)
--toPairs xs       = []
--
--distances pointCloud = Map.fromList $ 
--  commutativeApp dictDistance ([], pointCloud) where
--    dictDistance a b = ((a,b), distance a b)
--
--commutativeApp f (ac, x:xs) = commutativeApp f ((f x <$> xs) ++ ac, xs)
--commutativeApp f (ac, []  ) = ac
